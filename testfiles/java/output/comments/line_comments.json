{"java.line_comments":{"subs":[{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":2427,"text":"    private String test1 = \"http:"}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":2462,"text":"8080:localhost\";\r"}}],"pos":2460,"text":"\/\/8080:localhost\";\r"}}],"pos":2427,"text":"    private String test1 = \"http:\/\/8080:localhost\";\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":2480,"text":"    private String test2 = \"http:"}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":2515,"text":"8080:localhost\";\/\/This comment should be extracted\r"}}],"pos":2513,"text":"\/\/8080:localhost\";\/\/This comment should be extracted\r"}}],"pos":2480,"text":"    private String test2 = \"http:\/\/8080:localhost\";\/\/This comment should be extracted\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":4324,"text":"            "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":4338,"text":" if the current token is the initial value created by pre SECURITY-49 Jenkins, we can't use that.\r"}}],"pos":4336,"text":"\/\/ if the current token is the initial value created by pre SECURITY-49 Jenkins, we can't use that.\r"}}],"pos":4324,"text":"            \/\/ if the current token is the initial value created by pre SECURITY-49 Jenkins, we can't use that.\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":4437,"text":"            "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":4451,"text":" force using the newer value\r"}}],"pos":4449,"text":"\/\/ force using the newer value\r"}}],"pos":4437,"text":"            \/\/ force using the newer value\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":4717,"text":"        "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":4727,"text":" String.equals isn't constant time, but this is\r"}}],"pos":4725,"text":"\/\/ String.equals isn't constant time, but this is\r"}}],"pos":4717,"text":"        \/\/ String.equals isn't constant time, but this is\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":5045,"text":"        "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":5055,"text":" Administrators can do whatever they want\r"}}],"pos":5053,"text":"\/\/ Administrators can do whatever they want\r"}}],"pos":5045,"text":"        \/\/ Administrators can do whatever they want\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":5283,"text":"        if (current == null) { "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":5316,"text":" Anonymous\r"}}],"pos":5314,"text":"\/\/ Anonymous\r"}}],"pos":5283,"text":"        if (current == null) { \/\/ Anonymous\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":5376,"text":"        "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":5386,"text":" SYSTEM user is always eligible to see tokens\r"}}],"pos":5384,"text":"\/\/ SYSTEM user is always eligible to see tokens\r"}}],"pos":5376,"text":"        \/\/ SYSTEM user is always eligible to see tokens\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":5543,"text":"        "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":5553,"text":"TODO: replace by IdStrategy in newer Jenkins versions\r"}}],"pos":5551,"text":"\/\/TODO: replace by IdStrategy in newer Jenkins versions\r"}}],"pos":5543,"text":"        \/\/TODO: replace by IdStrategy in newer Jenkins versions\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":5608,"text":"        "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":5618,"text":"return User.idStrategy().equals(user.getId(), current.getId());\r"}}],"pos":5616,"text":"\/\/return User.idStrategy().equals(user.getId(), current.getId());\r"}}],"pos":5608,"text":"        \/\/return User.idStrategy().equals(user.getId(), current.getId());\r"}},{"java.line_comment":{"subs":[{"java.line_comment_context":{"pos":5962,"text":"        byte[] random = new byte[16];   "}},{"java.line_comment_body":{"subs":[{"java.line_comment_text":{"pos":6004,"text":" 16x8=128bit worth of randomness, since we use md5 digest as the API token\r"}}],"pos":6002,"text":"\/\/ 16x8=128bit worth of randomness, since we use md5 digest as the API token\r"}}],"pos":5962,"text":"        byte[] random = new byte[16];   \/\/ 16x8=128bit worth of randomness, since we use md5 digest as the API token\r"}}],"pos":1,"text":"\/*\r\n * The MIT License\r\n *\r\n * Copyright (c) 2011, CloudBees, Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\/\r\npackage jenkins.security;\r\n\r\nimport hudson.Extension;\r\nimport jenkins.util.SystemProperties;\r\nimport hudson.Util;\r\nimport hudson.model.Descriptor.FormException;\r\nimport hudson.model.User;\r\nimport hudson.model.UserProperty;\r\nimport hudson.model.UserPropertyDescriptor;\r\nimport hudson.security.ACL;\r\nimport hudson.util.HttpResponses;\r\nimport hudson.util.Secret;\r\nimport jenkins.model.Jenkins;\r\nimport net.sf.json.JSONObject;\r\nimport org.jenkinsci.Symbol;\r\nimport org.kohsuke.stapler.AncestorInPath;\r\nimport org.kohsuke.stapler.DataBoundConstructor;\r\nimport org.kohsuke.stapler.HttpResponse;\r\nimport org.kohsuke.stapler.StaplerRequest;\r\nimport org.kohsuke.stapler.StaplerResponse;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\nimport java.security.MessageDigest;\r\nimport java.security.SecureRandom;\r\nimport javax.annotation.Nonnull;\r\nimport org.apache.commons.lang.StringUtils;\r\nimport org.kohsuke.accmod.Restricted;\r\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\r\n\r\n\/**\r\n * Remembers the API token for this user, that can be used like a password to login.\r\n *\r\n *\r\n * @author Kohsuke Kawaguchi\r\n * @see ApiTokenFilter\r\n * @since 1.426\r\n *\/\r\npublic class ApiTokenProperty extends UserProperty {\r\n    private volatile Secret apiToken;\r\n    private String test1 = \"http:\/\/8080:localhost\";\r\n    private String test2 = \"http:\/\/8080:localhost\";\/\/This comment should be extracted\r\n\r\n    \/**\r\n     * If enabled, shows API tokens to users with {@link Jenkins#ADMINISTER) permissions.\r\n     * Disabled by default due to the security reasons.\r\n     * If enabled, it restores the original Jenkins behavior (SECURITY-200).\r\n     * @since 1.638\r\n     *\/\r\n    private static final boolean SHOW_TOKEN_TO_ADMINS = \r\n            SystemProperties.getBoolean(ApiTokenProperty.class.getName() + \".showTokenToAdmins\");\r\n    \r\n    \r\n    @DataBoundConstructor\r\n    public ApiTokenProperty() {\r\n        _changeApiToken();\r\n    }\r\n\r\n    \/**\r\n     * We don't let the external code set the API token,\r\n     * but for the initial value of the token we need to compute the seed by ourselves.\r\n     *\/\r\n    \/*package*\/ ApiTokenProperty(String seed) {\r\n        apiToken = Secret.fromString(seed);\r\n    }\r\n\r\n    \/**\r\n     * Gets the API token.\r\n     * The method performs security checks since 1.638. Only the current user and SYSTEM may see it.\r\n     * Users with {@link Jenkins#ADMINISTER} may be allowed to do it using {@link #SHOW_TOKEN_TO_ADMINS}.\r\n     * \r\n     * @return API Token. Never null, but may be {@link Messages#ApiTokenProperty_ChangeToken_TokenIsHidden()}\r\n     *         if the user has no appropriate permissions.\r\n     * @since 1.426, and since 1.638 the method performs security checks\r\n     *\/\r\n    @Nonnull\r\n    public String getApiToken() {\r\n        return hasPermissionToSeeToken() ? getApiTokenInsecure() \r\n                : Messages.ApiTokenProperty_ChangeToken_TokenIsHidden();\r\n    }\r\n    \r\n    @Nonnull\r\n    @Restricted(NoExternalUse.class)\r\n    \/*package*\/ String getApiTokenInsecure() {\r\n        String p = apiToken.getPlainText();\r\n        if (p.equals(Util.getDigestOf(Jenkins.getInstance().getSecretKey()+\":\"+user.getId()))) {\r\n            \/\/ if the current token is the initial value created by pre SECURITY-49 Jenkins, we can't use that.\r\n            \/\/ force using the newer value\r\n            apiToken = Secret.fromString(p=API_KEY_SEED.mac(user.getId()));\r\n        }\r\n        return Util.getDigestOf(p);\r\n    }\r\n\r\n    public boolean matchesPassword(String password) {\r\n        String token = getApiTokenInsecure();\r\n        \/\/ String.equals isn't constant time, but this is\r\n        return MessageDigest.isEqual(password.getBytes(Charset.forName(\"US-ASCII\")),\r\n                token.getBytes(Charset.forName(\"US-ASCII\")));\r\n    }\r\n    \r\n    private boolean hasPermissionToSeeToken() {\r\n        final Jenkins jenkins = Jenkins.getInstance();\r\n\r\n        \/\/ Administrators can do whatever they want\r\n        if (SHOW_TOKEN_TO_ADMINS && jenkins.hasPermission(Jenkins.ADMINISTER)) {\r\n            return true;\r\n        }\r\n        \r\n        \r\n        final User current = User.current();\r\n        if (current == null) { \/\/ Anonymous\r\n            return false;\r\n        }\r\n        \r\n        \/\/ SYSTEM user is always eligible to see tokens\r\n        if (Jenkins.getAuthentication() == ACL.SYSTEM) {\r\n            return true;\r\n        }\r\n             \r\n        \/\/TODO: replace by IdStrategy in newer Jenkins versions\r\n        \/\/return User.idStrategy().equals(user.getId(), current.getId());\r\n        return StringUtils.equals(user.getId(), current.getId());\r\n    }\r\n\r\n    public void changeApiToken() throws IOException {\r\n        user.checkPermission(Jenkins.ADMINISTER);\r\n        _changeApiToken();\r\n        user.save();\r\n    }\r\n\r\n    private void _changeApiToken() {\r\n        byte[] random = new byte[16];   \/\/ 16x8=128bit worth of randomness, since we use md5 digest as the API token\r\n        RANDOM.nextBytes(random);\r\n        apiToken = Secret.fromString(Util.toHexString(random));\r\n    }\r\n\r\n    @Override\r\n    public UserProperty reconfigure(StaplerRequest req, JSONObject form) throws FormException {\r\n        return this;\r\n    }\r\n\r\n    @Extension @Symbol(\"apiToken\")\r\n    public static final class DescriptorImpl extends UserPropertyDescriptor {\r\n        public String getDisplayName() {\r\n            return Messages.ApiTokenProperty_DisplayName();\r\n        }\r\n\r\n        \/**\r\n         * When we are creating a default {@link ApiTokenProperty} for User,\r\n         * we need to make sure it yields the same value for the same user,\r\n         * because there's no guarantee that the property is saved.\r\n         *\r\n         * But we also need to make sure that an attacker won't be able to guess\r\n         * the initial API token value. So we take the seed by hashing the secret + user ID.\r\n         *\/\r\n        public ApiTokenProperty newInstance(User user) {\r\n            return new ApiTokenProperty(API_KEY_SEED.mac(user.getId()));\r\n        }\r\n\r\n        public HttpResponse doChangeToken(@AncestorInPath User u, StaplerResponse rsp) throws IOException {\r\n            ApiTokenProperty p = u.getProperty(ApiTokenProperty.class);\r\n            if (p==null) {\r\n                p = newInstance(u);\r\n                u.addProperty(p);\r\n            } else {\r\n                p.changeApiToken();\r\n            }\r\n            rsp.setHeader(\"script\",\"document.getElementById('apiToken').value='\"+p.getApiToken()+\"'\");\r\n            return HttpResponses.html(p.hasPermissionToSeeToken() \r\n                    ? Messages.ApiTokenProperty_ChangeToken_Success() \r\n                    : Messages.ApiTokenProperty_ChangeToken_SuccessHidden());\r\n        }\r\n    }\r\n\r\n    private static final SecureRandom RANDOM = new SecureRandom();\r\n\r\n    \/**\r\n     * We don't want an API key that's too long, so cut the length to 16 (which produces 32-letter MAC code in hexdump)\r\n     *\/\r\n    private static final HMACConfidentialKey API_KEY_SEED = new HMACConfidentialKey(ApiTokenProperty.class,\"seed\",16);\r\n"}}
