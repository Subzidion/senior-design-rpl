{"java.dependencies":{"pos":1,"subs":[{"java.package":{"pos":1144,"subs":[{"java.package_text":{"pos":1152,"text":"jenkins.security"}}],"text":"package jenkins.security"}},{"java.dependencies_single":{"pos":1171,"subs":[{"java.dependencies_text":{"pos":1178,"text":"hudson.Extension"}}],"text":"import hudson.Extension"}},{"java.dependencies_single":{"pos":1196,"subs":[{"java.dependencies_text":{"pos":1203,"text":"jenkins.util.SystemProperties"}}],"text":"import jenkins.util.SystemProperties"}},{"java.dependencies_single":{"pos":1234,"subs":[{"java.dependencies_text":{"pos":1241,"text":"hudson.Util"}}],"text":"import hudson.Util"}},{"java.dependencies_single":{"pos":1254,"subs":[{"java.dependencies_text":{"pos":1261,"text":"hudson.model.Descriptor.FormException"}}],"text":"import hudson.model.Descriptor.FormException"}},{"java.dependencies_single":{"pos":1300,"subs":[{"java.dependencies_text":{"pos":1307,"text":"hudson.model.User"}}],"text":"import hudson.model.User"}},{"java.dependencies_single":{"pos":1326,"subs":[{"java.dependencies_text":{"pos":1333,"text":"hudson.model.UserProperty"}}],"text":"import hudson.model.UserProperty"}},{"java.dependencies_single":{"pos":1360,"subs":[{"java.dependencies_text":{"pos":1367,"text":"hudson.model.UserPropertyDescriptor"}}],"text":"import hudson.model.UserPropertyDescriptor"}},{"java.dependencies_single":{"pos":1404,"subs":[{"java.dependencies_text":{"pos":1411,"text":"hudson.security.ACL"}}],"text":"import hudson.security.ACL"}},{"java.dependencies_single":{"pos":1432,"subs":[{"java.dependencies_text":{"pos":1439,"text":"hudson.util.HttpResponses"}}],"text":"import hudson.util.HttpResponses"}},{"java.dependencies_single":{"pos":1466,"subs":[{"java.dependencies_text":{"pos":1473,"text":"hudson.util.Secret"}}],"text":"import hudson.util.Secret"}},{"java.dependencies_single":{"pos":1493,"subs":[{"java.dependencies_text":{"pos":1500,"text":"jenkins.model.Jenkins"}}],"text":"import jenkins.model.Jenkins"}},{"java.dependencies_single":{"pos":1523,"subs":[{"java.dependencies_text":{"pos":1530,"text":"net.sf.json.JSONObject"}}],"text":"import net.sf.json.JSONObject"}},{"java.dependencies_single":{"pos":1554,"subs":[{"java.dependencies_text":{"pos":1561,"text":"org.jenkinsci.Symbol"}}],"text":"import org.jenkinsci.Symbol"}},{"java.dependencies_single":{"pos":1583,"subs":[{"java.dependencies_text":{"pos":1590,"text":"org.kohsuke.stapler.AncestorInPath"}}],"text":"import org.kohsuke.stapler.AncestorInPath"}},{"java.dependencies_single":{"pos":1626,"subs":[{"java.dependencies_text":{"pos":1633,"text":"org.kohsuke.stapler.DataBoundConstructor"}}],"text":"import org.kohsuke.stapler.DataBoundConstructor"}},{"java.dependencies_single":{"pos":1675,"subs":[{"java.dependencies_text":{"pos":1682,"text":"org.kohsuke.stapler.HttpResponse"}}],"text":"import org.kohsuke.stapler.HttpResponse"}},{"java.dependencies_single":{"pos":1716,"subs":[{"java.dependencies_text":{"pos":1723,"text":"org.kohsuke.stapler.StaplerRequest"}}],"text":"import org.kohsuke.stapler.StaplerRequest"}},{"java.dependencies_single":{"pos":1759,"subs":[{"java.dependencies_text":{"pos":1766,"text":"org.kohsuke.stapler.StaplerResponse"}}],"text":"import org.kohsuke.stapler.StaplerResponse"}},{"java.dependencies_single":{"pos":1804,"subs":[{"java.dependencies_text":{"pos":1811,"text":"java.io.IOException"}}],"text":"import java.io.IOException"}},{"java.dependencies_single":{"pos":1832,"subs":[{"java.dependencies_text":{"pos":1839,"text":"java.nio.charset.Charset"}}],"text":"import java.nio.charset.Charset"}},{"java.dependencies_single":{"pos":1865,"subs":[{"java.dependencies_text":{"pos":1872,"text":"java.security.MessageDigest"}}],"text":"import java.security.MessageDigest"}},{"java.dependencies_single":{"pos":1901,"subs":[{"java.dependencies_text":{"pos":1908,"text":"java.security.SecureRandom"}}],"text":"import java.security.SecureRandom"}},{"java.dependencies_single":{"pos":1936,"subs":[{"java.dependencies_text":{"pos":1943,"text":"javax.annotation.Nonnull"}}],"text":"import javax.annotation.Nonnull"}},{"java.dependencies_single":{"pos":1968,"subs":[{"java.dependencies_text":{"pos":1975,"text":"org.apache.commons.lang.StringUtils"}}],"text":"import org.apache.commons.lang.StringUtils"}},{"java.dependencies_single":{"pos":2011,"subs":[{"java.dependencies_text":{"pos":2018,"text":"org.kohsuke.accmod.Restricted"}}],"text":"import org.kohsuke.accmod.Restricted"}},{"java.dependencies_single":{"pos":2049,"subs":[{"java.dependencies_text":{"pos":2056,"text":"org.kohsuke.accmod.restrictions.NoExternalUse"}}],"text":"import org.kohsuke.accmod.restrictions.NoExternalUse"}},{"java.dependencies_single":{"pos":2104,"subs":[{"java.dependencies_text":{"pos":2118,"text":"com.google.common.base.Preconditions.*"}}],"text":"import static com.google.common.base.Preconditions.*"}}],"text":"\/*\n * The MIT License\n *\n * Copyright (c) 2011, CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\/\npackage jenkins.security;\n\nimport hudson.Extension;\nimport jenkins.util.SystemProperties;\nimport hudson.Util;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.User;\nimport hudson.model.UserProperty;\nimport hudson.model.UserPropertyDescriptor;\nimport hudson.security.ACL;\nimport hudson.util.HttpResponses;\nimport hudson.util.Secret;\nimport jenkins.model.Jenkins;\nimport net.sf.json.JSONObject;\nimport org.jenkinsci.Symbol;\nimport org.kohsuke.stapler.AncestorInPath;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.security.MessageDigest;\nimport java.security.SecureRandom;\nimport javax.annotation.Nonnull;import org.apache.commons.lang.StringUtils;import org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\nimport static com.google.common.base.Preconditions.*;\n\n\/**\n * Remembers the API token for this user, that can be used like a password to login.\n *\n *\n * @author Kohsuke Kawaguchi\n * @see ApiTokenFilter\n * @since 1.426\n *\/\npublic class ApiTokenProperty extends UserProperty {\n    private volatile Secret apiToken;\n    private String test1 = \"http:\/\/8080:localhost\";\n    private String test2 = \"http:\/\/8080:localhost\";\/\/This comment should be extracted\n\n    \/**\n     * If enabled, shows API tokens to users with {@link Jenkins#ADMINISTER) permissions.\n     * Disabled by default due to the security reasons.\n     * If enabled, it restores the original Jenkins behavior (SECURITY-200).\n     * @since 1.638\n     *\/\n    private static final boolean SHOW_TOKEN_TO_ADMINS = \n            SystemProperties.getBoolean(ApiTokenProperty.class.getName() + \".showTokenToAdmins\");\n    \n    \n    @DataBoundConstructor\n    public ApiTokenProperty() {\n        _changeApiToken();\n    }\n\n    \/**\n     * We don't let the external code set the API token,\n     * but for the initial value of the token we need to compute the seed by ourselves.\n     *\/\n    \/*package*\/ ApiTokenProperty(String seed) {\n        apiToken = Secret.fromString(seed);\n    }\n\n    \/**\n     * Gets the API token.\n     * The method performs security checks since 1.638. Only the current user and SYSTEM may see it.\n     * Users with {@link Jenkins#ADMINISTER} may be allowed to do it using {@link #SHOW_TOKEN_TO_ADMINS}.\n     * \n     * @return API Token. Never null, but may be {@link Messages#ApiTokenProperty_ChangeToken_TokenIsHidden()}\n     *         if the user has no appropriate permissions.\n     * @since 1.426, and since 1.638 the method performs security checks\n     *\/\n    @Nonnull\n    public String getApiToken() {\n        return hasPermissionToSeeToken() ? getApiTokenInsecure() \n                : Messages.ApiTokenProperty_ChangeToken_TokenIsHidden();\n    }\n    \n    @Nonnull\n    @Restricted(NoExternalUse.class)\n    \/*package*\/ String getApiTokenInsecure() {\n        String p = apiToken.getPlainText();\n        if (p.equals(Util.getDigestOf(Jenkins.getInstance().getSecretKey()+\":\"+user.getId()))) {\n            \/\/ if the current token is the initial value created by pre SECURITY-49 Jenkins, we can't use that.\n            \/\/ force using the newer value\n            apiToken = Secret.fromString(p=API_KEY_SEED.mac(user.getId()));\n        }\n        return Util.getDigestOf(p);\n    }\n\n    public boolean matchesPassword(String password) {\n        String token = getApiTokenInsecure();\n        \/\/ String.equals isn't constant time, but this is\n        return MessageDigest.isEqual(password.getBytes(Charset.forName(\"US-ASCII\")),\n                token.getBytes(Charset.forName(\"US-ASCII\")));\n    }\n    \n    private boolean hasPermissionToSeeToken() {\n        final Jenkins jenkins = Jenkins.getInstance();\n\n        \/\/ Administrators can do whatever they want\n        if (SHOW_TOKEN_TO_ADMINS && jenkins.hasPermission(Jenkins.ADMINISTER)) {\n            return true;\n        }\n        \n        \n        final User current = User.current();\n        if (current == null) { \/\/ Anonymous\n            return false;\n        }\n        \n        \/\/ SYSTEM user is always eligible to see tokens\n        if (Jenkins.getAuthentication() == ACL.SYSTEM) {\n            return true;\n        }\n             \n        \/\/TODO: replace by IdStrategy in newer Jenkins versions\n        \/\/return User.idStrategy().equals(user.getId(), current.getId());\n        return StringUtils.equals(user.getId(), current.getId());\n    }\n\n    public void changeApiToken() throws IOException {\n        user.checkPermission(Jenkins.ADMINISTER);\n        _changeApiToken();\n        user.save();\n    }\n\n    private void _changeApiToken() {\n        byte[] random = new byte[16];   \/\/ 16x8=128bit worth of randomness, since we use md5 digest as the API token\n        RANDOM.nextBytes(random);\n        apiToken = Secret.fromString(Util.toHexString(random));\n    }\n\n    @Override\n    public UserProperty reconfigure(StaplerRequest req, JSONObject form) throws FormException {\n        return this;\n    }\n\n    @Extension @Symbol(\"apiToken\")\n    public static final class DescriptorImpl extends UserPropertyDescriptor {\n        public String getDisplayName() {\n            return Messages.ApiTokenProperty_DisplayName();\n        }\n\n        \/**\n         * When we are creating a default {@link ApiTokenProperty} for User,\n         * we need to make sure it yields the same value for the same user,\n         * because there's no guarantee that the property is saved.\n         *\n         * But we also need to make sure that an attacker won't be able to guess\n         * the initial API token value. So we take the seed by hashing the secret + user ID.\n         *\/\n        public ApiTokenProperty newInstance(User user) {\n            return new ApiTokenProperty(API_KEY_SEED.mac(user.getId()));\n        }\n\n        public HttpResponse doChangeToken(@AncestorInPath User u, StaplerResponse rsp) throws IOException {\n            ApiTokenProperty p = u.getProperty(ApiTokenProperty.class);\n            if (p==null) {\n                p = newInstance(u);\n                u.addProperty(p);\n            } else {\n                p.changeApiToken();\n            }\n            rsp.setHeader(\"script\",\"document.getElementById('apiToken').value='\"+p.getApiToken()+\"'\");\n            return HttpResponses.html(p.hasPermissionToSeeToken() \n                    ? Messages.ApiTokenProperty_ChangeToken_Success() \n                    : Messages.ApiTokenProperty_ChangeToken_SuccessHidden());\n        }\n    }\n\n    private static final SecureRandom RANDOM = new SecureRandom();\n\n    \/**\n     * We don't want an API key that's too long, so cut the length to 16 (which produces 32-letter MAC code in hexdump)\n     *\/\n    private static final HMACConfidentialKey API_KEY_SEED = new HMACConfidentialKey(ApiTokenProperty.class,\"seed\",16);\n}\n"}}
